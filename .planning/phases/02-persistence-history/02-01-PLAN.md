---
phase: 02-persistence-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/database/models.py, src/database/manager.py, tests/test_persistence.py]
autonomous: true
requirements: [SEC-03]

must_haves:
  truths:
    - "Can programmatically create a session and add multiple messages to it"
    - "Messages persist in a local SQLite file after the process terminates"
    - "Can retrieve all messages for a session in chronological order"
  artifacts:
    - path: "src/database/models.py"
      provides: "SQLAlchemy models for Session and Message"
    - path: "src/database/manager.py"
      provides: "Database access layer (save/load history)"
    - path: "ironclaw.db"
      provides: "SQLite database storage"
  key_links:
    - from: "src/database/manager.py"
      to: "src/database/models.py"
      via: "imports and session queries"
---

<objective>
Establish the persistence foundation using SQLAlchemy and SQLite.

Purpose: Provide a reliable storage layer for conversation history and session metadata.
Output: Database models and a manager for session/message operations.
</objective>

<execution_context>
@/home/brassy/.gemini/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define SQLAlchemy models</name>
  <files>src/database/models.py</files>
  <action>
    Create src/database/models.py using SQLAlchemy 2.0.
    Define:
    - Base class using DeclarativeBase.
    - ChatSession model: id (UUID/String), created_at (DateTime), metadata (JSON/String).
    - ChatMessage model: id (Integer/Autoincrement), session_id (FK), role (String: 'user', 'model', 'system', 'tool'), content (JSON/String - to store Pydantic AI ModelMessage blobs), timestamp (DateTime).
    Ensure models support storing raw ModelMessage structures from Pydantic AI for easy serialization/deserialization.
  </action>
  <verify>
    <automated>python3 -c "from src.database.models import ChatSession, ChatMessage; print('Models loaded')"</automated>
    <manual>None</manual>
    <sampling_rate>after task</sampling_rate>
  </verify>
  <done>Models are defined and can be imported without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Implement DatabaseManager and Tests</name>
  <files>src/database/manager.py, tests/test_persistence.py</files>
  <action>
    1. Implement DatabaseManager in src/database/manager.py:
       - Use an async engine with sqlite+aiosqlite.
       - Method `initialize_db()` to create tables.
       - Method `save_messages(session_id, messages)` to batch insert ModelMessages.
       - Method `get_messages(session_id)` to retrieve and deserialize ModelMessages.
       - Method `get_or_create_session(session_id=None)` to handle session continuity.
    2. Create tests/test_persistence.py to verify that:
       - Tables are created.
       - Messages are saved and retrieved correctly.
       - Session metadata is preserved.
  </action>
  <verify>
    <automated>pytest tests/test_persistence.py</automated>
    <manual>None</manual>
    <sampling_rate>after task</sampling_rate>
  </verify>
  <done>DatabaseManager passes persistence tests and ironclaw.db is created correctly.</done>
</task>

</tasks>

<verification>
Check that ironclaw.db is created in the project root after running tests.
Verify that multiple messages for a single session are returned in the correct order.
</verification>

<success_criteria>
1. Chat history can be saved to and loaded from a SQLite database using SQLAlchemy.
2. Pydantic AI ModelMessage objects are successfully serialized/deserialized.
</success_criteria>

<output>
After completion, create .planning/phases/02-persistence-history/02-01-SUMMARY.md
</output>
