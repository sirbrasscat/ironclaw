---
phase: 02-persistence-history
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified: [src/main.py, src/agent/core.py]
autonomous: true
requirements: [SEC-03]

must_haves:
  truths:
    - "User sees 'Loaded X previous messages' when starting the CLI"
    - "Old messages are displayed in the chat interface on restart"
    - "New user prompts and model responses are saved to the database"
    - "The agent maintains context from previous sessions (e.g., knows user's name across restarts)"
  artifacts:
    - path: "src/main.py"
      provides: "Updated agent loop with history loading/saving"
    - path: "src/agent/core.py"
      provides: "Support for message history if required (optional adjustments)"
  key_links:
    - from: "src/main.py"
      to: "src/database/manager.py"
      via: "get_or_create_session and save_messages"
---

<objective>
Integrate chat history persistence into the IronClaw CLI.

Purpose: Allow users to continue their conversations after closing the application.
Output: An updated CLI loop that reloads and saves history automatically.
</objective>

<execution_context>
@/home/brassy/.gemini/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-persistence-history/02-01-SUMMARY.md
@src/main.py
@src/database/manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update src/main.py to manage history</name>
  <files>src/main.py</files>
  <action>
    Modify src/main.py to:
    - Initialize the database on startup (using DatabaseManager).
    - Determine a session ID (default to a 'default' session for now, or use a UUID from a local .session file).
    - Fetch previous messages for the session before entering the loop.
    - If history exists:
      - Display the last few messages to the user (summary of the conversation).
      - Pass messages to the agent in the run() call using `message_history=history`.
    - After each interaction (both user prompt and model response), save all new messages to the database.
    - Use the pydantic_ai RunResult's `.all_messages()` or `.new_messages()` to identify what needs saving.
  </action>
  <verify>
    <automated>python3 -c "from src.main import main; print('main loop loadable')"</automated>
    <manual>Run CLI, type something, exit, restart, and see if it remembers the context.</manual>
    <sampling_rate>after task</sampling_rate>
  </verify>
  <done>CLI correctly reloads and persists history across app restarts.</done>
</task>

<task type="auto">
  <name>Task 2: Automatic session persistence and recovery</name>
  <files>src/main.py</files>
  <action>
    Improve session management:
    - Automatically create a 'default' session if none exists.
    - If the user provides a session ID via command line (optional feature), use that.
    - Ensure all message types (user prompts, model responses, tool calls, and tool outputs) are correctly saved.
    - Test that if the user approval flow happens, both the reasoning, approval, and resulting tool execution are saved.
  </action>
  <verify>
    <automated>pytest tests/test_persistence.py</automated>
    <manual>Perform a tool-calling action (e.g. 'run ls'), exit, restart, and ask 'what was the output of the last command?'.</manual>
    <sampling_rate>after task</sampling_rate>
  </verify>
  <done>Full conversation context (including tool results) is maintained across sessions.</done>
</task>

</tasks>

<verification>
Start the CLI.
Enter "My name is IronClaw User".
Exit.
Restart the CLI.
Ask "What is my name?".
Verify the agent correctly responds with "IronClaw User".
</verification>

<success_criteria>
1. User starts a new session and sees their previous chat history automatically reloaded.
2. The agent correctly maintains context from past interactions stored in the SQLite database.
</success_criteria>

<output>
After completion, create .planning/phases/02-persistence-history/02-02-SUMMARY.md
</output>
